# Total storage capacity
param max_space;

# Benefit of queries for configuration and configuration storage
set benefits, dimen 3;
set Sizes, dimen 2;

# Indices
set Queries := setof{(i,j,c) in benefits : j == 1} i;
set Indexes := setof{(i,s) in Sizes} i;
set E := setof{(i,j) in Queries cross Indexes} (i, j);

# Assignment
var x{(i,j) in E}, >=0, <=1, binary;
var y{Indexes}, >=0, <=1, binary;

maximize obj :
  sum{(i,j,c) in benefits} x[i,j] * c;

s.t. size :
  sum{(i,c) in Sizes} c * y[i] <= max_space;

<%
query_overlap.each do |query, overlaps|
  overlaps.each do |i, overlap|
    overlap.each do |j|
%>
s.t. q_<%= query + 1 %>_I_<%= i + 1 %>_<%= j + 1 %>_overlap :
  x[<%= query + 1 %>,<%= i + 1 %>] + x[<%= query + 1 %>,<%= j + 1 %>] < 2;
<%
    end
  end
end %>
<%
benefits.each_with_index do |qb, query|
  qb.each_with_index do |b, index|
    next unless b > 0 %>
s.t. q_<%= query + 1 %>_<%= index + 1 %>_avail :
  x[<%= query + 1 %>,<%= index + 1 %>] <= y[<%= index + 1 %>];

<%
  end
end %>

solve;

# Output the configuration
printf {i in Indexes: y[i] == 1} "%i ", i;

data;

# Total storage capacity
param max_space := <%= max_space %>;

set Sizes :=
<% index_sizes.each_with_index do |size, i| %>
  <%= i + 1 %> <%= size %>

<% end %>;

set benefits :=
<%
benefits.each_with_index do |qb, i|
  qb.each_with_index do |b, j| %>
  <%= i + 1 %> <%= j + 1 %> <%= b %>

<%
  end
end %>;

end;
